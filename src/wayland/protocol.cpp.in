// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 Maikel Nadolski <maikel.nadolski@gmail.com>

/*
 * WARNING: This file is automatically generated from wayland.xml.
 * Any manual modifications to this file will be lost when the generator is rerun.
 * 
 * To make changes, please modify the corresponding Wayland XML protocol 
 * definition or update the generator logic itself.
 */

#include "wayland/protocol.hpp"{% if extension %}
#include "wayland/{{ extension }}.hpp"{% endif %}

#include "stopped_as_optional.hpp"
#include "just_stopped.hpp"

namespace cw::protocol {
namespace {
template <class Value>
auto coro_just(Value val) -> cw::IoTask<Value> {
  co_return val;
}
} // namespace

{% for interface in interfaces %}
struct {{ interface.cppname }}Context : cw::ProxyInterface {
  explicit {{ interface.cppname }}Context(cw::ObjectId objectId, cw::Connection connection);
  ~{{ interface.cppname }}Context() override;

  auto handle_message(std::span<const char> message, cw::OpCode opCode) -> cw::IoTask<void> override;
  auto close() -> cw::Task<void>;

  auto get_handle() -> {{ interface.cppname }};

  {% if interface.events %}
  cw::AsyncQueue<std::variant<{% for event in interface.events %}{% if event.__tail %}, {% endif %}{{ interface.cppname }}::{{ event.cppname }}{% endfor %}>> mEventQueue;{% endif %}
};

{{ interface.cppname }}Context::{{ interface.cppname }}Context(cw::ObjectId objectId, cw::Connection connection)
: cw::ProxyInterface(objectId, connection){% if interface.events %}, mEventQueue(connection.get_scheduler()){% endif %} {}

{{ interface.cppname }}Context::~{{ interface.cppname }}Context() = default;

auto {{ interface.cppname }}Context::handle_message([[maybe_unused]] std::span<const char> message, cw::OpCode code) -> cw::IoTask<void> {
  switch (code) {
  {% for event in interface.events %}
  case cw::OpCode{ {{ event.num }} }: {
    {{ interface.cppname }}::{{ event.cppname }} eventData{};
    this->read_message(message{% for arg in event.args %}, eventData.{{ arg.name }}{% endfor %});
    co_await this->mEventQueue.push(std::move(eventData));
    break;
  }
  {% endfor %}
  default:
    break;
  }
  co_return;
}

auto {{ interface.cppname }}Context::close() -> cw::Task<void> {
  {% if interface.events %}co_await mEventQueue.close();{% else %}co_return;{% endif %}
}

auto {{ interface.cppname }}Context::get_handle() -> {{ interface.cppname }} {
  return {{ interface.cppname }}(this);
}

namespace {
struct {{ interface.cppname }}Resource {
  auto subscribe(std::function<auto(cw::IoTask<{{ interface.cppname }}>) -> cw::IoTask<void>> receiver) const -> cw::IoTask<void>;

  cw::ObjectId objectId;
  cw::Connection connection;
  std::function<void()> mSyncInit;
};

auto do{{ interface.cppname }}Make(cw::Connection connection, cw::ObjectId objectId, std::function<void()> syncInit, auto receiver) -> cw::IoTask<void> {
  {{interface.cppname }}Context context{objectId, connection};
  if (syncInit) {
    syncInit();
  }
  auto task = coro_just(context.get_handle());
  bool stopped = false;
  std::exception_ptr exception;
  try {
    stopped = (co_await cw::stopped_as_optional(
                  receiver(std::move(task))))
                  .has_value();
  } catch (const std::exception& e) {
    exception = std::current_exception();
  } catch (...) {
    exception = std::current_exception();
  }
  co_await context.close();
  if (stopped) {
    co_await cw::just_stopped();
  }
  if (exception) {
    std::rethrow_exception(exception);
  }
}

auto {{ interface.cppname }}Resource::subscribe(std::function<auto(cw::IoTask<{{ interface.cppname }}>) -> cw::IoTask<void>> receiver) const -> cw::IoTask<void> {
  return do{{ interface.cppname }}Make(connection, objectId, mSyncInit, std::move(receiver));
}
} // namespace

auto {{ interface.cppname }}::make(cw::ObjectId objectId, cw::Connection connection, std::function<void()> syncInit) -> cw::Observable<{{ interface.cppname }}> {
  return {{ interface.cppname }}Resource{objectId, connection, std::move(syncInit)};
}

{{ interface.cppname }}::{{ interface.cppname }}({{ interface.cppname }}Context* context)
    : mContext(context) {}

{{ interface.cppname }}::{{ interface.cppname }}() = default;

{{ interface.cppname }}::~{{ interface.cppname }}() = default;

auto {{ interface.cppname }}::get_object_id() const noexcept -> cw::ObjectId {
  return mContext->get_object_id();
}

{% for request in interface.requests %}
{% if request.return_type %}auto{% else %}void{% endif %}
{{ interface.cppname }}::{{ request.name }}({% for arg in request.args %}{% if arg.__tail %}, {% endif %}{{arg.type}} {{arg.name}}{% endfor %})
const {% if request.return_type %}-> cw::Observable<{{ request.return_type }}>{% endif %} {
  {% if request.return_type %}auto newObjectId = mContext->get_connection().get_next_object_id();
  auto syncInit = [=, context = this->mContext] {
    context->send_message(cw::OpCode{ {{ request.num }} }, newObjectId{% for arg in request.args %}, {{ arg.name }}{% endfor %});
  };
  return {{ request.return_type }}::make(newObjectId, mContext->get_connection(), std::move(syncInit));
  {% else %}mContext->send_message(cw::OpCode{ {{ request.num }} }{% for arg in request.args %}, {{ arg.name }}{% endfor %});
  {% endif %}
}
{% endfor %}
{% if interface.events %}
auto {{ interface.cppname }}::events() const -> cw::Observable<std::variant<{% for event in interface.events %}{% if event.__tail %}, {% endif %}{{ event.cppname }}{% endfor %}>> {
  return as_observable(mContext->mEventQueue);
}
{% endif %}
{% endfor %}

} // namespace cw
