// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 Maikel Nadolski <maikel.nadolski@gmail.com>

/*
 * WARNING: This file is automatically generated from wayland.xml.
 * Any manual modifications to this file will be lost when the generator is rerun.
 * 
 * To make changes, please modify the corresponding Wayland XML protocol 
 * definition or update the generator logic itself.
 */

#pragma once

#include "AsyncQueue.hpp"
#include "wayland/Connection.hpp"

#include <cstdint>
#include <string>
#include <string_view>
#include <variant>

namespace ms::wayland {

{% for interface in interfaces %}struct {{ interface.cppname }}Context;
{% endfor %}

{% for interface in interfaces %}class {{interface.cppname}};
{% endfor %}

{% for interface in interfaces %}
class {{ interface.cppname }} {
public:
  using context_type = {{ interface.cppname }}Context;

  static constexpr auto interface_name() noexcept -> std::string_view {
    return "{{ interface.name }}";
  }

  {{ interface.cppname }}();

  ~{{ interface.cppname }}();

  static auto make(ObjectId objectId, ConnectionHandle connection, std::function<void()> syncInit = nullptr) -> Observable<{{ interface.cppname }}>;

{% for entry in interface.enums %}
{% if entry.description %}/** @brief {{ entry.description }} */{% endif %}
  enum class {{ entry.cppname }} : uint32_t {
    {% for enum_value in entry.entries %}{{ enum_value.name }} = {{ enum_value.value }}{% if enum_value.__not_last %},{% endif %}{% endfor %}
  };
{% endfor %}

{% for event in interface.events %}struct {{ event.cppname }};
{% endfor %}
{% if interface.events %}
  auto events() const -> Observable<std::variant<{% for event in interface.events %}{% if event.__tail %}, {% endif %}{{ event.cppname }}{% endfor %}>>;
{% endif %}

{% for request in interface.requests %}
  {% if request.description %}/** @brief {{ request.description }} */{% endif %}
  {% if request.return_type %}auto{% else %}void{% endif %}
  {{ request.name }}({% for arg in request.args %}{% if arg.__tail %}, {% endif %}{{arg.type}} {{arg.name}}{% endfor %})
  const{% if request.return_type %}-> Observable<{{ request.return_type }}>{% endif %};
{% endfor %}

  auto get_object_id() const noexcept -> ObjectId;

private:
  friend class ConnectionHandle;

  explicit {{ interface.cppname }}({{ interface.cppname }}Context* context);

  {{ interface.cppname }}Context* mContext;
};
{% endfor %}

{% for interface in interfaces %}
{% for event in interface.events %}
{% if event.description %}/** @brief {{ event.description }} */
{% endif %}struct {{ interface.cppname }}::{{ event.cppname }} {
  static constexpr std::size_t index = {{ event.num }};
  {% for arg in event.args %}{% if arg.description %}/** @brief {{ arg.description }} */
  {% endif %}{{ arg.type }} {{ arg.name }};
  {% endfor %}
};
{% endfor %}
{% endfor %}

} // namespace ms
